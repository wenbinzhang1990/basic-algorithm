 * DFS&&BFS
 * DFS:深度优先遍历，前中后序都是，可使用递归，也可使用栈
 * BFS:广度优先遍历，使用队列，层序遍历就是一种BFS进阶

 树删除操作：
 1.叶子结点，直接删除
 2.近有左节点或者右节点，直接删除，父节点指向孙节点
 3.既有左节点也有右节点，删除后，讲右子树最小的节点删除后，替换上来


AVL总结：
1.平衡二叉搜索树
2.每个节点村balance={-1,0,1}
3.四种旋转操作

不足：节点需要存储额外信息，且调整频繁


 AVl树删除结点操作：
 平衡因子：树的查询效率取决于树的高度,所以有平衡因子取得是树的左右子树高度差
 左旋：
 1         2
  2   -》 1  3
   3
 右旋：
  3        2
 2    -》 1  3
1
 左右旋：
  3         3
 1    -》  2    -》  右旋
  2      1
 右左旋：
  3         3
    5    -》  4    -》  左旋
   4           5


 存在左右子树要注意：
  左右旋时，会涉及到原有子树的迁移。具体查看子树旋转.jpg


红黑树总结：
红黑树是一种近似平衡的二叉搜索书，它能够确保任何一个节点的左右子树的高度差小于两倍，退来说，红黑树是满足下述条件的二叉搜索树。
以下5点保证了左右子树的高度差小于2倍。
1.每个节点要么是红色，要么是黑色
2.根节点是黑色
3.每个叶节点是黑色的（nil节点，空节点）
4.不能有相邻接的两个红色节点
5.从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点



AVL和红黑树对比：
1.AVL查询比红黑树更快（因为AVL严格保证平衡）。
2.红黑树插入和删除比AVL快（因为红黑树相对宽松）。
3.AVL额外空间大，要存高度差，而红黑树只要一个bit，非红即黑。
4.读操作多，写操作少，用AVL。读操作和写操作差不多的话用红黑树。（数据库一般读多用avl，java类库一般用红黑树）